/// <reference types="google-cloud__datastore" />
import { Query as DsQuery, QueryResult } from '@google-cloud/datastore/query';
import { DatastoreTransaction as DSTransaction } from '@google-cloud/datastore/transaction';
import { Muds, DatastoreInt } from './muds';
import { MudsBaseEntity, MudsBaseStruct } from './muds-base-entity';
import { MudsManager, MudsEntityInfo } from './muds-manager';
import { Mubble } from '@mubble/core';
import { MudsQuery } from './muds-query';
import { RunContextServer } from '../..';
import { CommitResponse } from '@google-cloud/datastore/request';
import Datastore = require('@google-cloud/datastore');
/**
 * This is the main class on Muds system. All the Datastore operations should
 * originate from here.
 *
 * We intend to introduce exact datatypes and derived datatypes based on use cases like geoCoord
 *
 *
 *
 * Useful Links:
 * Basics: https://cloud.google.com/datastore/docs/concepts/entities
 * Limits: https://cloud.google.com/datastore/docs/concepts/limits
 * Project: https://github.com/googleapis/nodejs-datastore/
 * Node datastore ver 1.4: https://cloud.google.com/nodejs/docs/reference/datastore/1.4.x/Datastore
 * All Node docs: https://cloud.google.com/nodejs/docs/reference/libraries
 * Entity modelling: https://cloud.google.com/appengine/articles/modeling
 *
 */
/**
 *
 * Test cases:
 * - See if we are able to selectively index arrays
 * - Unique either needs to be implemented for array or disallowed
 * - A field that has multiple basic types, can it be indexed properly (will query work?)
 */
export declare abstract class MudsIo {
    protected rc: RunContextServer;
    protected manager: MudsManager;
    protected datastore: Datastore;
    readonly now: number;
    protected upsertQueue: MudsBaseEntity[];
    readonly uniques: UniqCacheObj[];
    constructor(rc: RunContextServer, manager: MudsManager);
    /**
     * newStruct: When you want to create a new instance of MudsStruct
     * * It is essentially new of the class with basic checks
     */
    newStruct<T extends MudsBaseStruct>(Cls: Muds.IBaseStruct<T>): T;
    /**
     * getExistingEntity: Call only when you just wish to read entity (no updates)
     * * Call this api when you are certain that entity exists in ds as it throws Muds.Error.RNF
     */
    getExistingEntity<T extends MudsBaseEntity>(entityClass: Muds.IBaseEntity<T>, ...keys: (string | DatastoreInt)[]): Promise<T>;
    /**
     * getExistingEntity: Call only when you just wish to check presence and read entity (no updates)
     */
    getEntityIfExists<T extends MudsBaseEntity>(entityClass: Muds.IBaseEntity<T>, ...keys: (string | DatastoreInt)[]): Promise<T>;
    getQueueBuilder(): QueueBuilder;
    getEntities(queueBuilder: QueueBuilder): Promise<(MudsBaseEntity | undefined)[]>;
    private getEntitiesInternal;
    /**
     * getForUpsert: Api to do insert or update on an entity
     * * Call this api to get editable entity either from ds or blank insertable copy
     * * This is just a convenience api (combination of getEntityIfExists / getForInsert)
     * * To check whether entity was fetched from ds: check entity.isFromDs()
     */
    getForUpsert<T extends Muds.BaseEntity>(entityClass: Muds.IBaseEntity<T>, ...keys: (string | DatastoreInt)[]): Promise<T>;
    /**
     * getForInsert: When you want to insert a new record in ds
     * * This would typically be with the key that will be generated by DS
     * * or sometimes when you are creating child of a parent like 'comment'
     */
    getForInsert<T extends MudsBaseEntity>(entityClass: Muds.IBaseEntity<T>, ...keys: (string | DatastoreInt)[]): T;
    enqueueForUpsert(entity: MudsBaseEntity): void;
    delete(...entities: MudsBaseEntity[]): Promise<void>;
    deleteKeys(queueBuilder: QueueBuilder): Promise<void>;
    query<T extends MudsBaseEntity>(entityClass: Muds.IBaseEntity<T>, ...ancestorKeys: (string | DatastoreInt)[]): MudsQuery<T>;
    getEntityBasedOnKeys(entityInfo: MudsEntityInfo, keys: any): Promise<QueryResult>;
    allocateSelfKey(entity: MudsBaseEntity): Promise<void>;
    private deleteInternal;
    protected abstract getExec(): Datastore | DSTransaction;
    abstract createQuery(entityName: string): DsQuery;
    protected processUpsertQueue(rc: RunContextServer): Promise<void>;
    protected processTransactionUpsertQueue(rc: RunContextServer, executedResults?: void | [CommitResponse]): Promise<void>;
    private removeUniquesFromCache;
    private checkUnique;
    private checkEntityExistsInDS;
    private getAllUniques;
    private lockEntityInCache;
    private getCacheKey;
    private existenceCheckQuery;
    private upsertImmediately;
    protected removeUniqFromCache(rc: RunContextServer): Promise<void>;
    getInfo(entityClass: Function | Muds.IBaseStruct<MudsBaseStruct> | Muds.IBaseEntity<MudsBaseEntity> | string): MudsEntityInfo;
    separateKeys<T extends Muds.BaseEntity>(rc: RunContextServer, entityClass: Muds.IBaseEntity<T>, keys: (string | DatastoreInt)[]): {
        ancestorKeys: (string | import("@google-cloud/datastore/entity").DatastoreInt)[];
        selfKey: string | import("@google-cloud/datastore/entity").DatastoreInt;
    };
    separateKeysForInsert<T extends Muds.BaseEntity>(rc: RunContextServer, entityClass: Muds.IBaseEntity<T>, keys: (string | DatastoreInt)[]): {
        ancestorKeys: (string | import("@google-cloud/datastore/entity").DatastoreInt)[];
        selfKey: string | import("@google-cloud/datastore/entity").DatastoreInt | undefined;
    };
    private checkKeyType;
    buildKeyForDs<T extends Muds.BaseEntity>(rc: RunContextServer, entityClass: Muds.IBaseEntity<T>, ancestorKeys: (string | DatastoreInt)[], selfKey: string | DatastoreInt | undefined): import("@google-cloud/datastore/entity").DatastoreKey;
    extractKeyFromDs<T extends Muds.BaseEntity>(rc: RunContextServer, entityClass: Muds.IBaseEntity<T>, rec: Mubble.uObject<any>): {
        ancestorKeys: (string | import("@google-cloud/datastore/entity").DatastoreInt)[];
        selfKey: string | import("@google-cloud/datastore/entity").DatastoreInt;
    };
    getRecordFromDs<T extends Muds.BaseEntity>(rc: RunContextServer, entityClass: Muds.IBaseEntity<T>, record: Mubble.uObject<any>, fullRec: boolean): T;
    verifyAncestorKeys<T extends Muds.BaseEntity>(rc: RunContextServer, entityClass: Muds.IBaseEntity<T>, ancestorKeys: (string | DatastoreInt)[]): import("@google-cloud/datastore/entity").DatastoreKey | null;
    checkIndexed(rc: RunContextServer, dottedStr: string, entityName: string): void;
    getReferredField(rc: RunContextServer, dottedStr: string, entityName: string): import("./muds-manager").MeField | undefined;
    destroy(): void;
}
export declare class MudsDirectIo extends MudsIo {
    private callback;
    constructor(rc: RunContextServer, manager: MudsManager, callback: (direct: Muds.DirectIo, now: number) => Promise<any>);
    run(): Promise<any>;
    protected getExec(): Datastore | DSTransaction;
    createQuery(entityName: string): DsQuery;
    private doCallback;
}
export declare class MudsTransaction extends MudsIo {
    private callback;
    private transaction;
    constructor(rc: RunContextServer, manager: MudsManager, callback: (transaction: Muds.Transaction, now: number) => Promise<any>);
    run(): Promise<any>;
    getExec(): Datastore | DSTransaction;
    createQuery(entityName: string): DsQuery;
    private doCallback;
    destroy(): void;
}
export interface IEntityKey<T extends MudsBaseEntity> {
    entityClass: Muds.IBaseEntity<T>;
    ancestorKeys: (string | DatastoreInt)[];
    selfKey: (string | DatastoreInt);
}
export declare class QueueBuilder {
    protected rc: RunContextServer;
    protected io: MudsIo;
    private arReq;
    private reqObj;
    constructor(rc: RunContextServer, io: MudsIo);
    add<T extends MudsBaseEntity>(entityClass: Muds.IBaseEntity<T>, ...keys: (string | DatastoreInt)[]): this;
    getAll(): IEntityKey<any>[];
}
export declare class UniqCacheObj {
    entity: MudsBaseEntity;
    key: string;
    value: string;
}
